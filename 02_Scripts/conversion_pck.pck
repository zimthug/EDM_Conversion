create or replace package conversion_pck is

  /** 
  * <b>Project:</b>  OpenSGC Data Conversion Module  <a href="http://41.220.242.130:8080/browse/EMCMS">EDM Project</a> <br>    
  * <b>Description:</b> This package will be used as the main data conversion package. It contains all the
  * necessary procedures and functions for converting data from EDM's current systems to the CMS.
  * The package is used to convert the following systems to CMS.                 
  *        <li>Galatee to CMS</li>
  *        <li>Access to CMS </li>
  *        <li>Eclipse to CMS</li>    
  * @author          tmlangeni@eservicios.indracompany.com
  * @version         edmconv_201312.beta
  */

  gll_run_id     number;
  gls_usuario    varchar2(15) := 'CONV_EDM';
  gls_programa   varchar2(15) := 'CONV_EDM';
  glf_fechanulla date := to_date(29991231, 'YYYYMMDD');

  /**
  * PL/SQL record type for customer names. Used for splitting the name into first, surname, other names and title.
  *
  * @author          tmlangeni@eservicios.indracompany.com
  */
  type name_rec is record(
    ape1_cli   varchar2(30),
    nom_cli    varchar2(30),
    ape2_cli   varchar2(30),
    cualif_cli varchar2(5));

  /**
  * Logging times and records loaded by the program. The logs are written to a database table called CONV_LOGGER
  * @author  tmlangeni@eservicios.indracompany.com
  * @param p_run_id The program ID number.
  * @param p_program_name The program identifier.
  * @param p_message The message to log
  * @param p_status Status of the program. Allowed values are (RUNNING,ABORTED,STARTING, ENDING)
  * @param p_row_count Number of rows processed by the program
  */
  procedure logger(p_run_id in number, p_program_name in varchar2,
                   p_message in varchar2, p_status in varchar2,
                   p_row_count in number);

  /**
  * Logs error messages which will be generated by programs as they run. The logs are written to a table ERROR_LOG.
  * @param p_error_msg The full error message generated.
  * @param p_run_id The program ID number.
  * @param p_program_name The program identifier.
  * @param p_tip_id Type of ID to use e.g. CONV_ID, OLD ACCOUNT etc.
  * @param p_id_number The ID number for the failing record.
  * @author  tmlangeni@eservicios.indracompany.com
  */
  procedure error_logger(p_error_msg in varchar2, p_run_id in number,
                         p_program_name in varchar2, p_tip_id in varchar2,
                         p_id_number in varchar2);

  /**
  * Mapping of old system codes to the equivalences in CMS
  * @param ls_system_id System in use. With 1 being Galatee, 2 Access and 3 Eclipse
  * @param ls_code_type Code type to lookup.
  * @param ls_code Old system code
  *
  * @author          tmlangeni@eservicios.indracompany.com
  *
  */
  function map_codes(ls_system_id in varchar2, ls_code_type in varchar2,
                     ls_code in varchar2) return varchar2;

  procedure p01_geographical_structure;

  procedure p02_int_supply_all(gls_system_id in varchar2);

  procedure p03_int_meter_galatee;

  procedure p03_int_meter_eclipse;

  procedure run_phase3;

  procedure p05_metering;

  procedure p06_readings;

  procedure p07_reading_routes;

  /**
  * 
  */
  procedure p20_billing(pll_nis_rad in number default 0);

  procedure p30_deposits;
end conversion_pck;
/
create or replace package body conversion_pck is

  gll_max_surname number := 25;

  type cadastramento_rec is record(
    system_id     varchar2(2),
    centre        varchar2(5),
    client        varchar2(12),
    ordre         varchar2(3),
    meter_no      varchar2(30),
    cod_calle     number,
    cod_unicom    number,
    plot_num      varchar2(10),
    telephone_one varchar2(30),
    telephone_two varchar2(30),
    address       varchar2(120),
    gps_x         float,
    gps_y         float,
    acc_finca     varchar2(50));

  procedure logger(p_run_id in number, p_program_name in varchar2,
                   p_message in varchar2, p_status in varchar2,
                   p_row_count in number) is
  begin
  
    insert into conv_logger
      (f_actual, run_id, program, message, status, row_count)
    values
      (sysdate, p_run_id, p_program_name, p_message, p_status, p_row_count);
    --commit;
  end logger;

  procedure error_logger(p_error_msg in varchar2, p_run_id in number,
                         p_program_name in varchar2, p_tip_id in varchar2,
                         p_id_number in varchar2) is
  begin
    insert into error_log
      (run_id, program_name, err_message, f_actual, tip_id, id_number)
    values
      (p_run_id, p_program_name, p_error_msg, sysdate, p_tip_id,
       p_id_number);
  end error_logger;

  procedure galatee_undefined_streets is
    cursor ix is
      select distinct centre from edmgalatee.client;
    ll_area             number;
    ll_cod_depto        number;
    ll_cod_calle        number;
    ll_cod_unicom       number;
    ll_cod_munic_maputo number;
    ll_cod_munic_matola number;
    ll_cod_local_maputo number;
    ll_cod_local_matola number;
    ls_nom_munic        varchar2(30);
    ls_nom_local        varchar2(30);
  begin
    for i in 1 .. 2 loop
      if i = 1 then
        select cod_depto
          into ll_cod_depto
          from deptos
         where nom_depto = 'MAPUTO CIDADE';
      
        select max(cod_munic) + 1 into ll_cod_munic_maputo from municipios;
      
        select max(cod_local) + 1
          into ll_cod_local_maputo
          from localidades;
      
        ls_nom_munic := 'UNDEFINED MAPUTO CIDADE';
      
      else
        select cod_depto
          into ll_cod_depto
          from deptos
         where nom_depto = 'MAPUTO PROVINCIA';
      
        select max(cod_munic) + 1 into ll_cod_munic_matola from municipios;
      
        select max(cod_local) + 1
          into ll_cod_local_matola
          from localidades;
      
        ls_nom_munic := 'UNDEFINED MAPUTO PROVINCIA';
      end if;
    
      insert into municipios
        (usuario, f_actual, programa, cod_prov, cod_depto, cod_munic,
         nom_munic, nas_code, nom_munic_arab)
      values
        ('CONV_EDM', trunc(sysdate), 'CONV_EDM', 1, ll_cod_depto,
         decode(i, 1, ll_cod_munic_maputo, ll_cod_munic_matola),
         ls_nom_munic, ' ', ls_nom_munic);
    
      ls_nom_local := ls_nom_munic;
    
      insert into localidades
        (usuario, f_actual, programa, cod_prov, cod_depto, cod_munic,
         cod_local, nom_local, area_ejec, nas_code, nom_local_arab)
      values
        ('CONV_EDM', trunc(sysdate), 'CONV_EDM', 1, ll_cod_depto,
         decode(i, 1, ll_cod_munic_maputo, ll_cod_munic_matola),
         decode(i, 1, ll_cod_local_maputo, ll_cod_local_matola),
         ls_nom_local, 0,
         decode(i, 1, ll_cod_local_maputo, ll_cod_local_matola),
         ls_nom_local);
    
    end loop;
  
    select max(cod_calle) into ll_cod_calle from callejero;
  
    for x in ix loop
    
      if x.centre in ('006', '040') then
        ll_area       := 2;
        ll_cod_unicom := 3013;
      elsif x.centre in ('050') then
        ll_area       := 2;
        ll_cod_unicom := 1260;
      elsif x.centre in ('060') then
        ll_area       := 2;
        ll_cod_unicom := 1312;
      else
        ll_area       := 1;
        ll_cod_unicom := 5101;
      end if;
    
      ll_cod_calle := ll_cod_calle + 1;
    
      select cod_depto
        into ll_cod_depto
        from municipios
       where cod_munic =
             decode(ll_area, 1, ll_cod_munic_maputo, ll_cod_munic_matola);
    
      insert into callejero
        (usuario, f_actual, programa, cod_calle, cod_prov, cod_depto,
         cod_munic, cod_local, nom_calle, tip_via, cod_unicom, cod_oficom,
         ind_urb_rur, cod_post, cod_centec, tip_via2, nas_code,
         nom_calle_arab, ifs_dep_code)
      values
        ('CONV_EDM', trunc(sysdate), 'CONV_EDM', ll_cod_calle, 1,
         ll_cod_depto,
         decode(ll_area, 1, ll_cod_munic_maputo, ll_cod_munic_matola),
         decode(ll_area, 1, ll_cod_local_maputo, ll_cod_local_matola),
         'UNDEFINED CENTRE ' || x.centre, 'TV008', ll_cod_unicom,
         ll_cod_unicom, 1, ' ', ll_cod_unicom, ' ', ll_cod_calle,
         'UNDEFINED CENTRE ' || x.centre, 0);
    
    end loop;
  end galatee_undefined_streets;

  procedure p01_geographical_structure is
  
    cursor lcur_deptos is
      select distinct cod_pro,
                      trim(regexp_replace(prov, '[[:punct:]]', null)) prov
        from edmgalatee.dg_geostruct
       where cod_pro in (10, 11, 9);
  
    cursor lcur_munic(pll_cod_pro in number) is
      select distinct cod_dist, distrito
        from edmgalatee.dg_geostruct
       where cod_pro = pll_cod_pro
         and cod_unicom is not null
       order by 2;
  
    cursor lcur_localidade(pll_cod_dist in number) is
      select distinct e.cod_pa, e.pa, e.cod_loc, e.loc,
                      pa || case
                        when loc = pa then
                         null
                        else
                         ' - ' || loc
                      end localidade
        from edmgalatee.dg_geostruct e
       where cod_dist = pll_cod_dist
         and cod_unicom is not null
       order by 1;
  
    cursor lcur_callejero(pll_cod_pa in number, pll_cod_loc in number) is
      select distinct e.cod_bairro, e.bairro, e.cod_unicom
        from edmgalatee.dg_geostruct e
       where cod_pa = pll_cod_pa
         and cod_loc = pll_cod_loc
         and cod_unicom is not null;
  
    ll_cod_depto  number;
    ll_cod_munic  number;
    ll_cod_local  number;
    ll_cod_calle  number;
    ll_cod_unicom number;
    ll_cod_prov   number := 1;
    ls_usuario    varchar2(15) := 'CONV_EDM';
    ls_programa   varchar2(15) := 'CONV_EDM';
  begin
    select nvl(max(cod_depto), 9) into ll_cod_depto from intfopen.deptos;
  
    select nvl(max(cod_munic) + 5, 99)
      into ll_cod_munic
      from intfopen.municipios;
  
    select nvl(max(cod_local) + 50, 999)
      into ll_cod_local
      from intfopen.localidades;
  
    select nvl(max(cod_calle) + 100, 50)
      into ll_cod_calle
      from intfopen.callejero;
  
    for lcur_deptos_rec in lcur_deptos loop
    
      ll_cod_depto := ll_cod_depto + 1;
    
      insert into intfopen.deptos
        (usuario, f_actual, programa, cod_prov, cod_depto, nom_depto,
         nom_depto_arab)
      values
        (ls_usuario, trunc(sysdate), ls_programa, ll_cod_prov, ll_cod_depto,
         upper(lcur_deptos_rec.prov), upper(lcur_deptos_rec.prov));
    
      update edmgalatee.dg_geostruct a
         set cod_depto = ll_cod_depto
       where a.cod_pro = lcur_deptos_rec.cod_pro;
    
      for lcur_munic_rec in lcur_munic(lcur_deptos_rec.cod_pro) loop
      
        ll_cod_munic := ll_cod_munic + 1;
      
        insert into intfopen.municipios
          (usuario, f_actual, programa, cod_prov, cod_depto, cod_munic,
           nom_munic, nas_code, nom_munic_arab)
        values
          (ls_usuario, trunc(sysdate), ls_programa, ll_cod_prov,
           ll_cod_depto, ll_cod_munic, upper(lcur_munic_rec.distrito), ' ',
           upper(lcur_munic_rec.distrito));
      
        update edmgalatee.dg_geostruct a
           set a.cod_munic = ll_cod_munic
         where a.cod_dist = lcur_munic_rec.cod_dist;
      
        for lcur_localidade_rec in lcur_localidade(lcur_munic_rec.cod_dist) loop
        
          ll_cod_local := ll_cod_local + 1;
        
          insert into intfopen.localidades
            (usuario, f_actual, programa, cod_prov, cod_depto, cod_munic,
             cod_local, nom_local, area_ejec, nas_code, nom_local_arab)
          values
            (ls_usuario, trunc(sysdate), ls_programa, ll_cod_prov,
             ll_cod_depto, ll_cod_munic, ll_cod_local,
             upper(trim(lcur_localidade_rec.localidade)), 0, ll_cod_local,
             upper(trim(lcur_localidade_rec.localidade)));
        
          update edmgalatee.dg_geostruct a
             set a.cod_local = ll_cod_local
           where a.cod_pa = lcur_localidade_rec.cod_pa
             and a.cod_loc = lcur_localidade_rec.cod_loc;
        
          for lcur_callejero_rec in lcur_callejero(lcur_localidade_rec.cod_pa,
                                                   lcur_localidade_rec.cod_loc) loop
          
            ll_cod_calle := ll_cod_calle + 1;
          
            /*if lcur_callejero_rec.cod_unicom is null then
              ll_cod_unicom := 8011;       
            end if;*/
          
            ll_cod_unicom := lcur_callejero_rec.cod_unicom;
          
            insert into intfopen.callejero
              (usuario, f_actual, programa, cod_calle, cod_prov, cod_depto,
               cod_munic, cod_local, nom_calle, tip_via, cod_unicom,
               cod_oficom, ind_urb_rur, cod_post, cod_centec, tip_via2,
               nas_code, nom_calle_arab, ifs_dep_code)
            values
              (ls_usuario, trunc(sysdate), ls_programa, ll_cod_calle,
               ll_cod_prov, ll_cod_depto, ll_cod_munic, ll_cod_local,
               upper(trim(lcur_callejero_rec.bairro)), 'TV008',
               ll_cod_unicom, ll_cod_unicom, 1, ' ', ll_cod_unicom, ' ',
               ll_cod_calle, upper(trim(lcur_callejero_rec.bairro)), 0);
          
            update edmgalatee.dg_geostruct a
               set a.cod_calle = ll_cod_calle, a.cod_unicom = ll_cod_unicom
             where a.cod_bairro = lcur_callejero_rec.cod_bairro;
          
          end loop;
        end loop;
      end loop;
    end loop;
    galatee_undefined_streets;
  end p01_geographical_structure;

  procedure split_long_names(pls_name in varchar2, names$ out name_rec) is
    /** 
    * Procedure to split customer names into first name, surname, other names and title.
    * 
    * @author          tmlangeni@eservicios.indracompany.com
    */
    ls_name     varchar2(400);
    ls_nom_cli  varchar2(260);
    ls_ape1_cli varchar2(260);
  begin
    ls_name := replace(replace(replace(pls_name, '.', ' '), '&', ' '), '-',
                       ' ');
    for i in 1 .. length(ls_name) loop
      ls_ape1_cli := trim(substr(pls_name, 1, instr(ls_name, ' ', -1, i)));
      ls_nom_cli  := trim(substr(pls_name, instr(ls_name, ' ', -1, i)));
    
      if length(ls_ape1_cli) <= gll_max_surname then
        exit;
      end if;
    end loop;
  
    names$.ape2_cli := ' ';
    names$.nom_cli  := substr(ls_nom_cli, 1, 30);
    names$.ape1_cli := substr(ls_ape1_cli, 1, 25);
  
  exception
    when others then
      dbms_output.put_line('SPLIT_LONG_NAMES  Error: ' || sqlerrm ||
                           ' ::>' || pls_name);
  end split_long_names;

  /*function get_galatee_address(pls_centre in varchar2,
                               pls_client in varchar2) return varchar2 is
    --Getting customer address from  the Galatee database.
    ls_address varchar2(60);
  begin
    select nvl(trim('|' || nomrue || ' ' || numrue || ' ' || comprue || ' ' ||
                     etage), ' ')
      into ls_address
      from edmgalatee.ag
     where centre = pls_centre
       and ag = pls_client;
    return ls_address;
  exception
    when no_data_found then
      return null;
  end get_galatee_address;*/

  function map_codes(ls_system_id in varchar2, ls_code_type in varchar2,
                     ls_code in varchar2) return varchar2 is
    ls_return varchar2(5);
  begin
    select cms_code
      into ls_return
      from int_map_codes a
     where a.system_id = ls_system_id
       and a.code_type = ls_code_type
       and a.obs_code = ls_code
       and a.cms_code is not null;
  
    return ls_return;
  
  exception
    when no_data_found then
      return ls_code_type;
  end map_codes;

  function sanitize_address(pls_duplicador in varchar2) return varchar2 is
    ls_address varchar2(300);
  begin
    ls_address := nvl(regexp_replace(pls_duplicador, '[[:cntrl:]]', null),
                      ' ');
    if substr(ls_address, 1, 1) <> '|' then
      ls_address := '|' || ls_address;
    end if;
  
    return replace(ls_address, '~', null);
  end sanitize_address;

  procedure normalize_int_supply is
  begin
  
    update int_supply set duplicador = ' ' where duplicador is null;
  
    /*  Put num_puerta (house/ plot number) from Data Gathering */
    /*for lcur_puerta_rec in (select duplicador, num_puerta, client,
                                   c.bocl_nocasa, s.rowid
                              from int_supply s,
                                   edmcamp.customers_registered_one c
                             where s.client = lpad(c.bocl_nocontador, 11, 0)
                               and num_puerta is null
                               and bocl_nocasa is not null
                               and regexp_like(bocl_nocasa, '[[:digit:]]')
                            union all
                            select duplicador, num_puerta, client,
                                   c.bocl_nocasa, s.rowid
                              from int_supply s,
                                   edmcamp.customers_registered_one c
                             where s.client =
                                   lpad(c.bocl_contratonumero, 7, 0)
                               and s.centre =
                                   lpad(c.bocl_contratoagencia, 3, 0)
                               and num_puerta is null
                               and bocl_nocasa is not null
                               and regexp_like(bocl_nocasa, '[[:digit:]]')) loop
      begin
        update int_supply
           set num_puerta = lcur_puerta_rec.bocl_nocasa
         where rowid = lcur_puerta_rec.rowid;
      exception
        when others then
          null;
      end;
    end loop;*/
  
    /*  Separate telephone numbers which were put as two numbers in one field from old system*/
    begin
      for x in (select rowid, telefone1,
                       substr(telefone1, 1, instr(telefone1, '/') - 1) new_1,
                       substr(telefone1, instr(telefone1, '/') + 1) new_2
                  from int_supply
                 where telefone1 like '%/%'
                   and length(substr(telefone1, instr(telefone1, '/'))) > 4
                   and length(substr(telefone1, 1, instr(telefone1, '/'))) > 4
                   and regexp_instr(telefone1, '[[:alpha:]]') = 0
                   and telefone2 is null) loop
      
        update int_supply
           set telefone1 = x.new_1, telefone2 = x.new_2
         where rowid = x.rowid;
      
      end loop;
    end;
  
    begin
      for x in (select rowid, telefone1,
                       substr(telefone1, 1, instr(telefone1, '/') - 1) new_1,
                       substr(telefone1, instr(telefone1, '/') + 1) new_2
                  from int_supply
                 where telefone1 like '%/%'
                   and length(substr(telefone1, instr(telefone1, '/'))) > 4
                   and length(substr(telefone1, 1, instr(telefone1, '/'))) > 4
                   and regexp_instr(telefone1, '[[:alpha:]]') = 0
                   and telefone2 is not null) loop
      
        update int_supply set telefone1 = x.new_1 where rowid = x.rowid;
      
      end loop;
    end;
  
  end normalize_int_supply;

  procedure process_supply_data(cadastramento$ in out cadastramento_rec) is
    lf_date_created date;
    ls_premise_type varchar2(100);
    ls_address_dg   varchar2(400);
  begin
    begin
      if cadastramento$.system_id in ('01', '02') then
        select d.cod_calle, d.cod_unicom
          into cadastramento$.cod_calle, cadastramento$.cod_unicom
          from edmcamp.cadastramento c, edmgalatee.dg_geostruct d
         where c.bairro_id = d.cod_bairro
           and c.centre = to_char(to_number(cadastramento$.centre))
           and c.client = to_char(to_number(cadastramento$.client))
           and rownum <= 1;
      elsif cadastramento$.system_id = '03' then
        /* For Eclipse we use the meter not the account numbers. */
        select d.cod_calle, d.cod_unicom
          into cadastramento$.cod_calle, cadastramento$.cod_unicom
          from edmcamp.cadastramento c, edmgalatee.dg_geostruct d
         where c.bairro_id = d.cod_bairro
           and c.meter_no = to_char(to_number(cadastramento$.client))
           and rownum <= 1;
      end if;
    exception
      when no_data_found then
        cadastramento$.cod_calle  := null;
        cadastramento$.cod_unicom := null;
    end;
  
    begin
      ls_address_dg := cadastramento$.address;
    
      if cadastramento$.system_id in ('01', '02') then
        select a.gps_x, a.gps_y, a.landmark_descriptive_address,
               substr(a.plot_hse_no, 1, 10), a.bocl_telemovel_1,
               a.bocl_telemovel_2, a.meter_no, a.premise_type,
               a.date_of_creation
          into cadastramento$.gps_x, cadastramento$.gps_y, ls_address_dg,
               cadastramento$.plot_num, cadastramento$.telephone_one,
               cadastramento$.telephone_two, cadastramento$.meter_no,
               ls_premise_type, lf_date_created
          from edmcamp.cadastramento a
         where a.client = to_char(to_number(cadastramento$.client))
           and a.centre = to_char(to_number(cadastramento$.centre))
           and rownum <= 1;
      else
        select a.gps_x, a.gps_y, a.landmark_descriptive_address,
               substr(a.plot_hse_no, 1, 10), a.bocl_telemovel_1,
               a.bocl_telemovel_2, a.meter_no, a.premise_type,
               a.date_of_creation
          into cadastramento$.gps_x, cadastramento$.gps_y, ls_address_dg,
               cadastramento$.plot_num, cadastramento$.telephone_one,
               cadastramento$.telephone_two, cadastramento$.meter_no,
               ls_premise_type, lf_date_created
          from edmcamp.cadastramento a
         where a.meter_no = to_char(to_number(cadastramento$.client))
           and rownum <= 1;
      end if;
    
      ls_address_dg := substr(ls_address_dg, 1, 90);
    
      if trim(ls_address_dg) is not null and
         trim(cadastramento$.address) is null then
        cadastramento$.address   := trim(ls_address_dg);
        cadastramento$.acc_finca := substr(ls_address_dg, 1, 50);
      else
        cadastramento$.acc_finca := nvl(substr(ls_address_dg, 1, 50),
                                        substr(cadastramento$.address, 1, 50));
        cadastramento$.address   := substr(cadastramento$.address, 1, 90);
      end if;
    
    exception
      when no_data_found then
        cadastramento$.acc_finca := ' ';
        cadastramento$.address   := nvl(substr(cadastramento$.address, 1, 90),
                                        ' ');
    end;
  end process_supply_data;

  /**
  * <b>Procedure</b></br>
  * Procedure to load the table INT_SUPPLY with the data from Galatee, Access and Eclipse. 
  * INT_SUPPLY is the main staging table for creation of premise, customer, account, supply point 
  * and service data for CMS. It is in this table where the data is 
  * transformed and CMS equivalence codes are added to the data. 
  *
  * @param gls_system_id This is varchar2 in. The valid values for this parameter are
  * <ul>
  *  <li> '01' - For Galatee</li>
  *  <li> '02' - For Access</li>
  *  <li> '03' - For Eclipse</li>
  * </ul>
  * It is required to specify the system one would like to convert for table INT_SUPPLY
  * @author tmlangeni@eservicios.indracompany.com
  */
  procedure p02_int_supply_all(gls_system_id in varchar2) is
  
    type lcur_data_rec is record(
      system_id varchar2(2),
      centre    varchar2(10),
      client    varchar2(20),
      ordre     varchar2(2),
      fullname  varchar2(300),
      title     varchar2(30),
      firstname varchar2(120),
      surname   varchar2(120),
      tarif     varchar2(60),
      address   varchar2(4000),
      nuit      varchar2(30),
      tel_one   varchar2(30),
      tel_two   varchar2(30),
      email     varchar2(300),
      pot       float,
      f_baja    date,
      f_alta    date,
      est_serv  varchar2(5));
  
    lcur_data_rec$     lcur_data_rec;
    lf_alta            date;
    lf_baja            date;
    ll_potencia        float;
    ll_conv_id         number;
    ll_cod_mask        number;
    ll_gr_concepto     number;
    ll_imp_tot_rec     number;
    ll_imp_deposito    number;
    ll_cod_unicom_serv number;
    names$             name_rec;
    ls_conso           varchar2(9);
    ls_cod_tar         varchar2(3);
    ls_est_sum         varchar2(5);
    ls_tip_fin         varchar2(5);
    ls_tip_cod         varchar2(5);
    ls_tip_cli         varchar2(5);
    ls_tip_doc         varchar2(5);
    ls_cod_cnae        varchar2(5);
    ls_doc_id          varchar2(12);
    ls_address         varchar2(90);
    ls_acc_finca       varchar2(50);
    lcur_data          sys_refcursor;
    cadastramento$     cadastramento_rec;
  
    function get_galatee_record return sys_refcursor is
      lcur_galatee sys_refcursor;
    begin
      open lcur_galatee for
        select '01' system_id, a.centre, a.client, c.ordre,
               c.nomabon fullname, denabon title, ' ' firstname,
               nomabon surname, a.tarif,
               nvl(trim('|' || nomrue || ' ' || numrue || ' ' || comprue || ' ' ||
                         etage), ' ') address, nuit, g.telephone tel_one,
               ' ' tel_two, c.email, a.puissance pot, a.dres f_baja,
               a.dabon f_alta,
               case
                 when trim(dres) is null then
                  'EC012'
                 else
                  'EC021'
               end est_serv
          from edmgalatee.client c, edmgalatee.abon a, edmgalatee.ag g
         where c.centre = a.centre
           and c.centre = g.centre
           and c.client = a.client
           and c.client = g.ag
           and not exists (select 0
                  from int_supply
                 where centre = c.centre
                   and client = c.client
                   and ordre = c.ordre);
    
      return lcur_galatee;
    end get_galatee_record;
  
    function get_access_record return sys_refcursor is
      lcur_access sys_refcursor;
    begin
      open lcur_access for
        select '02' system_id, to_char(d.zona) centre,
               to_char(d.no_da_instalacao) client, '0' ordre,
               trim(apelido || ' ' || nome) fullname, ' ' title,
               apelido firstname, nome surname, to_char(d.categoria) tarif,
               '|' || endereco address, nuit, ' ' tel_one, ' ' tel_two,
               d.email, d.potencia pot, t.datanovocontador f_baja,
               t.data_de_instalacao f_alta,
               decode(d.activo, 1, 'EC012', 'EC021') est_serv
          from edmaccess.consumidores d, edmaccess.contador t
         where d.zona = t.zona
           and d.no_da_instalacao = t.no_da_instalacao
           and not exists
         (select 0
                  from int_supply
                 where centre = to_char(d.zona)
                   and client = to_char(d.no_da_instalacao));
    
      return lcur_access;
    end get_access_record;
  
    function get_eclipse_record return sys_refcursor is
      lcur_eclipse sys_refcursor;
    begin
      open lcur_eclipse for
        select '03' system_id, '999' centre, msno client, '00' ordre,
               trim(e.legal_entity_name || ' ' || e.first_names) fullname,
               ' ' title, first_names firstname, e.legal_entity_name surname,
               e.meter_trf_code tarif,
               trim('|' || e.loc_addr1 || ' ' || e.loc_addr2 || ' ' ||
                     e.loc_addr3) address, ' ' nuit, e.tel tel_one,
               ' ' tel_two, e.email, 0 pot,
               to_date(29991231, 'yyyymmdd') f_baja, e.inst_date f_alta,
               'EC012' est_serv
          from edmeclipse.customer_data e
         where status = 'Active'
           and regexp_instr(msno, '[[:alpha:]]') = 0
           and not exists
         (select 0 from int_supply where client = e.msno);
    
      return lcur_eclipse;
    end get_eclipse_record;
  
  begin
  
    select run_id.nextval into gll_run_id from dual;
  
    select nvl(max(conv_id), 1000000) into ll_conv_id from int_supply;
  
    if gls_system_id = '01' then
      lcur_data := get_galatee_record;
    elsif gls_system_id = '02' then
      lcur_data := get_access_record;
    elsif gls_system_id = '03' then
      lcur_data := get_eclipse_record;
    else
      raise_application_error(-20008,
                              'You have specified invalid parameter for system to convert.' ||
                               chr(10) ||
                               'Valid values are ''01'',''02'' and ''03''');
    end if;
  
    loop
      begin
        fetch lcur_data
          into lcur_data_rec$;
        exit when lcur_data%notfound;
        --Reset values for types to remove values from previous record.
        names$                   := null;
        cadastramento$           := null;
        ll_conv_id               := ll_conv_id + 1;
        cadastramento$.ordre     := lcur_data_rec$.ordre;
        cadastramento$.centre    := lcur_data_rec$.centre;
        cadastramento$.client    := lcur_data_rec$.client;
        cadastramento$.address   := lcur_data_rec$.address;
        cadastramento$.system_id := lcur_data_rec$.system_id;
      
        process_supply_data(cadastramento$);
      
        lf_alta := nvl(lcur_data_rec$.f_alta, trunc(sysdate));
        lf_baja := nvl(lcur_data_rec$.f_baja, glf_fechanulla);
      
        if gls_system_id = '01' then
        
          select lpad(conso, 6, '0')
            into ls_conso
            from edmgalatee.client a
           where centre = lcur_data_rec$.centre
             and client = lcur_data_rec$.client
             and ordre = lcur_data_rec$.ordre;
        
        elsif gls_system_id = '02' then
          select tipo_de_client
            into ls_conso
            from edmaccess.consumidores c
           where zona = lcur_data_rec$.centre
             and c.no_da_instalacao = lcur_data_rec$.client;
        elsif gls_system_id = '03' then
          ls_conso := '0000';
        end if;
      
        --Get tariff and related items 
        if gls_system_id = '03' then
          lcur_data_rec$.tarif := '0';
        end if;
      
        begin
          select a.cod_tar, a.gr_concepto, cod_mask
            into ls_cod_tar, ll_gr_concepto, ll_cod_mask
            from int_map_tariffs a
           where a.system_id = lcur_data_rec$.system_id
             and to_number(a.obs_tariff) = to_number(lcur_data_rec$.tarif);
        
          select cod_mask
            into ll_cod_mask
            from intfopen.mtarifas
           where cod_tar = ls_cod_tar;
        
        exception
          when no_data_found then
            ls_cod_tar     := null;
            ll_cod_mask    := null;
            ll_gr_concepto := null;
        end;
      
        ls_tip_cli := map_codes(ls_system_id => '01',
                                ls_code_type => 'TC000', ls_code => ls_conso);
      
        /*
        This is a crude way to map types, however i think there is no better way right now
        Maybe the data from DATA_GATHERING will have these types properly mapped
        */
        if ls_cod_tar in ('E01', 'E02') then
          ls_tip_fin := 'TF105';
          ls_tip_cod := 'PT001';
        elsif ls_cod_tar in ('E03', 'E05') then
          ls_tip_fin := 'TF501';
          ls_tip_cod := 'PT005';
        else
          ls_tip_fin := 'TF235';
          ls_tip_cod := 'PT002';
        end if;
      
        --Setting the TIP_DOC and DOC_ID values.
        ls_doc_id  := ' ';
        ls_tip_doc := 'TD001';
      
        if ls_tip_cli <> 'TC001' and trim(lcur_data_rec$.nuit) is not null and
           regexp_instr(lcur_data_rec$.nuit, '[[:alpha:]]') = 0 then
          ls_tip_doc := 'TD007';
          ls_doc_id  := substr(lcur_data_rec$.nuit, 1, 15);
        end if;
      
        --Setting the names.....
        if lcur_data_rec$.system_id = '01' then
          if length(lcur_data_rec$.fullname) > gll_max_surname then
            split_long_names(lcur_data_rec$.fullname, names$);
          else
            names$.ape1_cli := lcur_data_rec$.fullname;
          end if;
        else
          if length(lcur_data_rec$.firstname) <= 30 and
             length(lcur_data_rec$.surname) <= 25 then
            names$.ape1_cli := lcur_data_rec$.surname;
            names$.nom_cli  := lcur_data_rec$.firstname;
          else
            if length(lcur_data_rec$.fullname) < 60 then
              split_long_names(lcur_data_rec$.fullname, names$);
            else
              split_long_names(lcur_data_rec$.surname, names$);
            end if;
          end if;
        end if;
      
        if ls_cod_tar in ('E01', 'E04', 'E09', 'E10') then
          ls_cod_cnae := '1000';
        elsif ls_cod_tar in ('E03', 'E11') then
          ls_cod_cnae := '3000';
        elsif ls_cod_tar in ('E02', 'E12') then
          ls_cod_cnae := '2000';
        elsif ls_cod_tar in ('E05') then
          ls_cod_cnae := '5000';
        elsif ls_cod_tar in ('E07') then
          ls_cod_cnae := '4000';
        elsif ls_cod_tar in ('E08') then
          ls_cod_cnae := '7000';
        elsif ls_cod_tar in ('E06') then
          ls_cod_cnae := '6000';
        else
          ls_cod_cnae := '9999';
        end if;
      
        if lcur_data_rec$.system_id = '01' then
          begin
          
            select nvl(sum(decode(dc, 'D', montant, -montant)), 0)
              into ll_imp_tot_rec
              from edmgalatee.lclient
             where centre = lcur_data_rec$.centre
               and client = lcur_data_rec$.client
               and ordre = lcur_data_rec$.ordre
               and coper not in ('070', '075');
          exception
            when no_data_found then
              ll_imp_tot_rec := 0;
          end;
        
          begin
            /*Security deposit bills */
            select nvl(sum(decode(dc, 'D', montant, -montant)), 0)
              into ll_imp_deposito
              from edmgalatee.lclient
             where centre = lcur_data_rec$.centre
               and client = lcur_data_rec$.client
               and ordre = lcur_data_rec$.ordre
               and coper in ('070', '075');
          exception
            when no_data_found then
              ll_imp_deposito := 0;
          end;
        
        end if;
      
        ls_address   := sanitize_address(cadastramento$.address);
        ls_acc_finca := sanitize_address(cadastramento$.acc_finca);
      
        names$.nom_cli := nvl(regexp_replace(names$.nom_cli, '[[:cntrl:]]',
                                             null), ' ');
      
        names$.ape1_cli := nvl(regexp_replace(names$.ape1_cli, '[[:cntrl:]]',
                                              null), ' ');
      
        names$.ape2_cli := nvl(regexp_replace(names$.ape2_cli, '[[:cntrl:]]',
                                              null), ' ');
      
        --Give customers streets and unicoms....
        if lcur_data_rec$.system_id = '01' and
           cadastramento$.cod_calle is null then
          select cod_calle, cod_unicom
            into cadastramento$.cod_calle, cadastramento$.cod_unicom
            from callejero
           where nom_calle = 'UNDEFINED CENTRE ' || lcur_data_rec$.centre;
        end if;
      
        begin
          select cod_unicom_serv
            into ll_cod_unicom_serv
            from int_offices
           where cod_mask = ll_cod_mask
             and cod_unicom = cadastramento$.cod_unicom;
        exception
          when no_data_found then
            ll_cod_unicom_serv := 0;
        end;
      
        ll_potencia := lcur_data_rec$.pot;
      
        if trim(ls_acc_finca) is null or trim(ls_acc_finca) = '|' then
          ls_acc_finca := substr(ls_address, 1, 50);
        end if;
      
        ls_est_sum := lcur_data_rec$.est_serv;
      
        insert into int_supply
          (conv_id, system_id, centre, client, ordre, nomabon, ape1_cli,
           ape2_cli, nom_cli, cualif_cli, duplicador, acc_finca, cod_calle,
           est_sum, nuit, cod_unicom, f_alta, f_baja, cod_mask, cod_tar,
           gr_concepto, email, telefone1, doc_id, tip_doc, tip_fin, tip_cod,
           tip_cli, gis_x, gis_y, pot, telefone2, cod_cnae, imp_tot_rec,
           imp_deposito, cod_unicom_serv)
        values
          (ll_conv_id, lcur_data_rec$.system_id, lcur_data_rec$.centre,
           lcur_data_rec$.client, lcur_data_rec$.ordre,
           lcur_data_rec$.fullname, names$.ape1_cli, names$.ape2_cli,
           names$.nom_cli, names$.cualif_cli, ls_address, ls_acc_finca,
           cadastramento$.cod_calle, ls_est_sum, lcur_data_rec$.nuit,
           cadastramento$.cod_unicom, lf_alta, lf_baja, ll_cod_mask,
           ls_cod_tar, ll_gr_concepto, lcur_data_rec$.email,
           nvl(cadastramento$.telephone_one, ' '), ls_doc_id, ls_tip_doc,
           ls_tip_fin, ls_tip_cod, ls_tip_cli, nvl(cadastramento$.gps_x, 0),
           nvl(cadastramento$.gps_y, 0), ll_potencia,
           nvl(cadastramento$.telephone_two, ' '), ls_cod_cnae,
           ll_imp_tot_rec, ll_imp_deposito, ll_cod_unicom_serv);
      
      exception
        when others then
          dbms_output.put_line(sqlerrm || '  --> ' ||
                               lcur_data_rec$.client);
      end;
    end loop;
  
    normalize_int_supply;
  
  end p02_int_supply_all;

  procedure p03_int_meter_galatee is
    cursor lcur_int_meter is
      select *
        from edmgalatee.canalisation a
       where (centre, ag) in (select centre, client from int_supply)
         and a.point = 1
         and datedepose is null
         and regexp_instr(a.compteur, '[[:digit:]]') > 0
         and a.compteur is not null
         and a.compteur not in
             ('A00CREDELEC', 'A0000009999', 'A0000000000', '000000000000',
              'A00RAMAL', 'A00000FALHA', 'A0DUPLICADO', 'CR0000000000',
              'A00000RAMAL', 'A0000000001', 'A00DUPLICADO', 'A00CREDELC',
              'A00000000000')
         and a.compteur not like '%CREDELEC%'
         and not exists (select 0
                from int_meter
               where centre = a.centre
                 and client = a.ag);
    lf_visit        date;
    ll_same         number;
    ll_conv_id      number;
    ls_co_marca     varchar2(5);
    ls_co_modelo    varchar2(5);
    ls_tip_apa      varchar2(5);
    ls_co_marca_dup varchar2(5);
    ls_num_apa      varchar2(20);
    ls_camp_num_apa varchar2(20);
  begin
    select nvl(max(conv_id), 1000000) into ll_conv_id from int_meter;
  
    for lcur_int_meter_rec in lcur_int_meter loop
    
      ls_co_marca  := 'MC999';
      ls_co_modelo := 'ML001';
    
      if lcur_int_meter_rec.produit = '02' then
        ls_tip_apa := 'TA165';
        --TODO: How do we differentiate the two meters here....
      else
        ls_tip_apa := 'TA101';
      end if;
    
      ll_conv_id := ll_conv_id + 1;
    
      begin
        select c.bocl_nocontador, c.bocl_dtligacao
          into ls_camp_num_apa, lf_visit
          from edmcamp.customers_registered c
         where c.bocl_contratoagencia =
               to_char(to_number(lcur_int_meter_rec.centre))
           and c.bocl_contratonumero =
               to_char(to_number(lcur_int_meter_rec.ag))
           and rownum <= 1
           and c.bocl_dtligacao =
               (select max(bocl_dtligacao)
                  from edmcamp.customers_registered c
                 where c.bocl_contratoagencia =
                       to_char(to_number(lcur_int_meter_rec.centre))
                   and c.bocl_contratonumero =
                       to_char(to_number(lcur_int_meter_rec.ag)));
      exception
        when no_data_found then
          ls_camp_num_apa := null;
      end;
    
      ls_num_apa := null;
    
      if ls_camp_num_apa is not null and
         lf_visit > lcur_int_meter_rec.datepose then
        ls_num_apa := ls_camp_num_apa;
      else
        ls_num_apa := lcur_int_meter_rec.compteur;
      end if;
      /*
      if ls_camp_num_apa is null or
         regexp_instr(ls_camp_num_apa, '[[:digit:]]') = 0 then
        ls_num_apa := lcur_int_meter_rec.compteur;
      else
        if length(ls_camp_num_apa) = 10 and
           substr(ls_camp_num_apa, 1, 2) in ('13') then
          ls_num_apa := '0' || ls_camp_num_apa;
        else
          ls_num_apa := ls_camp_num_apa;
        end if;
      */
      --Prepaid meter /*TODO*/ confirm if this is correct
      if substr(ls_num_apa, 1, 2) in ('01', '22') and
         length(ls_num_apa) = 11 then
        ls_tip_apa := 'TA100';
      end if;
    
      insert into int_meter
        (conv_id, system_id, centre, client, ordre, compteur, num_apa,
         co_marca, co_modelo, tip_apa, est_apa, co_prop_apa, f_inst, cte_apa,
         f_fabric, sec_pm, sec_apa, camp_num_apa)
      values
        (ll_conv_id, 1, lcur_int_meter_rec.centre, lcur_int_meter_rec.ag,
         lcur_int_meter_rec.produit, lcur_int_meter_rec.compteur, ls_num_apa,
         ls_co_marca, ls_co_modelo, ls_tip_apa, 'AP011', 'PA003',
         lcur_int_meter_rec.datepose, 1, (lcur_int_meter_rec.datepose - 30),
         1, 1, ls_camp_num_apa);
    
    end loop;
    ll_same     := 0;
    ls_num_apa  := ' ';
    ls_co_marca := ' ';
  
    --check for duplicates. The code will be executed thrice making sure all duplicates are removed.
    for cont in 1 .. 3 loop
      for lcur_duplicate_rec in (select m.*, rowid
                                   from int_meter m
                                  where (num_apa, co_marca) in
                                        (select num_apa, co_marca
                                           from int_meter
                                          group by num_apa, co_marca
                                         having count(*) between 2 and 10)
                                  order by num_apa, co_marca) loop
      
        if ls_num_apa = lcur_duplicate_rec.num_apa and
           ls_co_marca = lcur_duplicate_rec.co_marca then
        
          ll_same := ll_same + 1;
        
          select cod
            into ls_co_marca_dup
            from (select cod, rownum re
                     from (select cod
                              from codigos
                             where cod like 'MC___'
                               and cod_mask <> 0
                             order by 1))
           where re = ll_same;
        
          update int_meter
             set co_marca = ls_co_marca_dup
           where rowid = lcur_duplicate_rec.rowid;
        
        else
          ll_same := 0;
        end if;
      
        ls_num_apa  := lcur_duplicate_rec.num_apa;
        ls_co_marca := lcur_duplicate_rec.co_marca;
      
      end loop;
    end loop;
  end p03_int_meter_galatee;

  procedure p03_int_meter_eclipse is
    cursor lcur_int_meter is
      select *
        from edmeclipse.customer_data x
       where msno in (select client from int_supply)
         and not exists
       (select 0 from int_meter where num_apa = x.msno);
    ll_conv_id   number;
    ls_tip_apa   varchar2(5);
    ls_co_marca  varchar2(5);
    ls_co_modelo varchar2(5);
    ls_num_apa   varchar2(20);
  begin
    select nvl(max(conv_id), 1000000) into ll_conv_id from int_meter;
  
    for lcur_int_meter_rec in lcur_int_meter loop
    
      if substr(lcur_int_meter_rec.msno, 1, 2) = '01' then
        ls_co_marca := 'MC020';
      elsif substr(lcur_int_meter_rec.msno, 1, 2) = '04' then
        ls_co_marca := 'MC023';
      elsif substr(lcur_int_meter_rec.msno, 1, 2) = '14' then
        ls_co_marca := 'MC999';
      elsif substr(lcur_int_meter_rec.msno, 1, 2) = '22' then
        ls_co_marca := 'MC999';
      else
        ls_co_marca := 'MC999';
      end if;
    
      ls_tip_apa   := 'TA100';
      ls_co_modelo := 'ML001';
    
      ls_num_apa := lcur_int_meter_rec.msno;
    
      ll_conv_id := ll_conv_id + 1;
    
      insert into int_meter
        (conv_id, system_id, centre, client, ordre, compteur, num_apa,
         co_marca, co_modelo, tip_apa, est_apa, co_prop_apa, f_inst, cte_apa,
         f_fabric, sec_pm, sec_apa)
      values
        (ll_conv_id, 3, '999', lcur_int_meter_rec.msno, '00',
         lcur_int_meter_rec.msno, ls_num_apa, ls_co_marca, ls_co_modelo,
         ls_tip_apa, 'AP011', 'PA003', lcur_int_meter_rec.inst_date, 1,
         (lcur_int_meter_rec.inst_date - 30), 1, 1);
    
    end loop;
  end p03_int_meter_eclipse;

  procedure run_phase3 is
  begin
    conversion_fincas;
    conversion_clientes;
    conversion_cuentas_cu;
    conversion_sumcon;
  end run_phase3;

  procedure p05_metering is
    /* 
     * TML
    */
    cursor lcur_main is
      select m.conv_id, m.centre, m.client, m.ordre, m.num_apa, m.co_marca,
             m.co_modelo, m.tip_apa, m.est_apa, m.rowid, m.f_inst,
             m.co_prop_apa, m.cte_apa, m.f_fabric, s.nis_rad, s.nif,
             s.cod_cli, s.f_alta, s.f_baja, s.tip_fase, s.tip_tension
        from int_meter m, int_supply s
       where m.centre = s.centre
         and m.client = s.client
         and m.ind_converted is null
         and s.nis_rad is not null;
    ls_tip_pm   varchar2(5);
    ls_num_id   varchar2(5);
    ls_num_lote varchar2(15) := '301300000000001';
  begin
  
    insert into apa_lotes
      (usuario, f_actual, programa, num_lote, documento, est_lote, cantidad,
       responsable, observaciones, cod_almacen_origen, cod_almacen_destinado,
       f_cambio, f_return, test_lote)
    values
      (gls_usuario, trunc(sysdate), gls_programa, ls_num_lote, ' ', 'CM036',
       0, ' ', 'CONVERTED MTRS', 3013, 3013, trunc(sysdate), glf_fechanulla,
       ' ');
  
    for lcur_main_rec in lcur_main loop
    
      if lcur_main_rec.tip_apa in ('TA165', 'TA166') then
        ls_tip_pm := 'MB500';
      else
        ls_tip_pm := 'MB501';
      end if;
    
      ls_num_id := 'AM000';
    
      lcur_main_rec.f_inst := nvl(lcur_main_rec.f_inst,
                                  lcur_main_rec.f_alta - 30);
    
      lcur_main_rec.f_fabric := nvl(lcur_main_rec.f_fabric,
                                    lcur_main_rec.f_alta - 30);
    
      insert into puntomed
        (usuario, f_actual, programa, nif_pm, cgv_pm, aol_pm, acc_pm,
         sec_pm)
      values
        (gls_usuario, trunc(sysdate), gls_programa, lcur_main_rec.nif, 0, 1,
         'AP017', 1);
    
      lcur_main_rec.tip_fase := nvl(lcur_main_rec.tip_fase, 'FA001');
    
      lcur_main_rec.tip_tension := nvl(lcur_main_rec.tip_tension, 'TM001');
    
      insert into puntomed_param
        (usuario, f_actual, programa, nis_rad, sec_apa, f_val, f_anul,
         nif_apa, sec_pm, tip_fase, tip_tension, tip_pm, observacion,
         aol_apa, num_id, valor, porc_csmo, ind_estm, valor1, valor2, datos)
      values
        (gls_usuario, trunc(sysdate), gls_programa, lcur_main_rec.nis_rad,
         1, lcur_main_rec.f_alta, glf_fechanulla, lcur_main_rec.nif, 1,
         lcur_main_rec.tip_fase, lcur_main_rec.tip_tension, ls_tip_pm, ' ',
         10, ls_num_id, 0, 0, 2, 0, 0, '/0/0/');
    
      begin
        insert into aparatos
          (usuario, f_actual, programa, num_apa, co_marca, co_modelo,
           tip_apa, est_apa, cod_almacen, co_prop_apa, f_fabric,
           f_prox_calibracion, f_prox_verificacion, num_lote, lugar,
           observaciones, nis_rad, nif_apa, sec_pm, num_precin, error,
           co_condition, defect, co_fabric, lect, num_os, cod_emp, num_order,
           num_tender, cod_agent, f_guarantee, num_msr, usage_purpose,
           ii_result, num_license, num_bill, num_test, num_apa_mf)
        values
          (gls_usuario, trunc(sysdate), gls_programa, lcur_main_rec.num_apa,
           lcur_main_rec.co_marca, lcur_main_rec.co_modelo,
           lcur_main_rec.tip_apa, 'CM036', 3013, lcur_main_rec.co_prop_apa,
           lcur_main_rec.f_fabric, glf_fechanulla, glf_fechanulla,
           ls_num_lote, ' ', ' ', lcur_main_rec.nis_rad, lcur_main_rec.nif,
           1, ' ', ' ', 'AP011', 'DF000', 'FA000', 0, 0, 0, ' ', ' ',
           'AG000', glf_fechanulla, ' ', 'MU000', ' ', ' ', ' ', ' ',
           lcur_main_rec.num_apa);
      
        insert into haparatos
          (usuario, f_actual, programa, num_apa, co_marca, f_cambio,
           est_apa, cod_almacen, num_lote, nis_rad, nif_apa, sec_pm,
           num_precin, tip_apa, co_modelo, error, co_condition, defect, lect,
           num_os, cod_emp)
          select usuario, f_actual, programa, num_apa, co_marca,
                 trunc(sysdate), est_apa, cod_almacen, num_lote, nis_rad,
                 nif_apa, sec_pm, num_precin, tip_apa, co_modelo, error,
                 co_condition, defect, lect, num_os, cod_emp
            from aparatos
           where num_apa = lcur_main_rec.num_apa
             and co_marca = lcur_main_rec.co_marca;
      
        insert into apmedida_ap
          (usuario, f_actual, programa, nis_rad, num_apa, co_marca, est_apa,
           nif_sum, cgv_sum, nif_apa, tip_apa, co_prop_apa, aol_apa,
           amperios, tip_fase, tip_tension, coef_per, f_lvto, f_inst,
           cte_apa, f_fabric, f_urevis, ind_precin, f_precin, tip_per_lect,
           sec_pm, regulador, dimen_conex, sec_apa, frena, svorkov,
           num_precin, apa_id, f_ppm, co_accuracy, installed_by, defect)
        values
          (gls_usuario, trunc(sysdate), gls_programa, lcur_main_rec.nis_rad,
           lcur_main_rec.num_apa, lcur_main_rec.co_marca,
           lcur_main_rec.est_apa, lcur_main_rec.nif, ' ', lcur_main_rec.nif,
           lcur_main_rec.tip_apa, lcur_main_rec.co_prop_apa, 10, ls_num_id,
           lcur_main_rec.tip_fase, lcur_main_rec.tip_tension, 0,
           glf_fechanulla, lcur_main_rec.f_inst, 1, lcur_main_rec.f_fabric,
           glf_fechanulla, 2, glf_fechanulla, 'RU012', 1, ' ', 0, 1, 0, 0,
           '/0/0/', lcur_main_rec.tip_tension, glf_fechanulla, 'CY001', 1,
           'DF000');
      
        /*for params in 1..3 loop
          if lcur_main_rec.tip_apa in ('TA101', 'TA100') then
            exit;
          end if;
          null;
        end loop;*/
      
        update int_meter
           set ind_converted = 1
         where rowid = lcur_main_rec.rowid;
      
      exception
        when dup_val_on_index then
          dbms_output.put_line('Duplicate meter ' || lcur_main_rec.num_apa || '  ' ||
                               lcur_main_rec.co_marca);
      end;
    end loop;
  end p05_metering;

  procedure p06_readings is
    /*%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     * TML - 2013-09-20
     * Readings Module   
     *  
     *%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    */
    cursor lcur_readings is
      select /*+ parallel=8 */
       sp.nis_rad, sp.sec_nis, ev.point, dateevt, periode, codeevt, indexevt,
       conso, matricule, mt.f_inst, mt.num_apa, co_marca, sp.centre,
       sp.client, tip_apa, sp.f_alta, ev.compteur
        from edmgalatee.evenement ev, int_meter mt, int_supply sp
       where ev.centre = sp.centre
         and ev.ag = sp.client
         and mt.centre = sp.centre
         and mt.client = sp.client
         and ev.compteur in (select compteur
                               from edmgalatee.canalisation
                              where centre = sp.centre
                                and ag = sp.client)
         and sp.nis_rad is not null
         and ev.indexevt is not null
         and ev.dateevt > add_months(sysdate, -24)
         and not exists
       (select 0 from apmedida_co where nis_rad = sp.nis_rad)
       order by sp.nis_rad, periode;
    ll_cte      number;
    ll_commit   number;
    ll_num_rue  number;
    ll_nis_rad  number;
    ls_tip_csmo varchar2(5);
    ls_tip_lect varchar2(5);
  begin
    ll_commit  := 0;
    ll_nis_rad := 0;
  
    for lcur_readings_rec in lcur_readings loop
    
      begin
        select coeflect, cadcompt
          into ll_cte, ll_num_rue
          from edmgalatee.canalisation c
         where ag = lcur_readings_rec.client
           and centre = lcur_readings_rec.centre
           and point = lcur_readings_rec.point;
        /* and c.datepose =
        (select max(datepose)
           from edmgalatee.canalisation c
          where ag = lcur_readings_rec.client
            and centre = lcur_readings_rec.centre
            and point = lcur_readings_rec.point);*/
      exception
        when no_data_found then
          ll_cte     := 1;
          ll_num_rue := 5;
        when too_many_rows then
          ll_cte     := 1;
          ll_num_rue := 5;
      end;
    
      if ll_cte = 0 then
        ll_cte := 1;
      end if;
    
      if ll_num_rue > 8 then
        ll_num_rue := 8;
      end if;
    
      ls_tip_lect := 'RA005';
    
      if lcur_readings_rec.point = 1 and
         lcur_readings_rec.tip_apa = 'TA101' then
        ls_tip_csmo := 'CO111';
      elsif lcur_readings_rec.point = 1 and
            lcur_readings_rec.tip_apa <> 'TA101' then
        ls_tip_csmo := 'CO111';
      elsif lcur_readings_rec.point = 2 and
            lcur_readings_rec.tip_apa <> 'TA101' then
        ls_tip_csmo := 'CO331';
      elsif lcur_readings_rec.point = 3 and
            lcur_readings_rec.tip_apa <> 'TA101' then
        ls_tip_csmo := 'CO551';
      end if;
    
      ll_num_rue := nvl(ll_num_rue, 5);
    
      if ll_nis_rad <> lcur_readings_rec.nis_rad or ls_tip_csmo <> 'CO111' then
        begin
          insert into apmedida_param
            (usuario, f_actual, programa, num_apa, co_marca, f_val,
             tip_csmo, coef_per, cte_prim, cte_secund, peso_entr, peso_sal,
             num_rue)
          values
            (gls_usuario, trunc(sysdate), gls_programa,
             lcur_readings_rec.num_apa, lcur_readings_rec.co_marca,
             nvl(lcur_readings_rec.f_inst, lcur_readings_rec.f_alta),
             ls_tip_csmo, 0, ll_cte, 1, 0, 0, ll_num_rue);
        exception
          when dup_val_on_index then
            null;
        end;
      end if;
    
      begin
        insert into apmedida_co
          (usuario, f_actual, programa, nis_rad, num_apa, co_marca,
           tip_csmo, lect, f_lect, csmo, cte, tip_lect, f_fact, dif_lect,
           sec_rec, num_rue, sec_lect, lect_ant, f_trat, co_al, cod_emp,
           time_lect)
        values
          (gls_usuario, trunc(sysdate), gls_programa,
           lcur_readings_rec.nis_rad, lcur_readings_rec.num_apa,
           lcur_readings_rec.co_marca, ls_tip_csmo,
           lcur_readings_rec.indexevt, lcur_readings_rec.dateevt,
           lcur_readings_rec.conso, ll_cte, ls_tip_lect,
           lcur_readings_rec.dateevt,
           round(lcur_readings_rec.conso / ll_cte), 0, ll_num_rue, 0, 0,
           lcur_readings_rec.dateevt, 'AN000', 0, 0);
      
        if ll_nis_rad <> lcur_readings_rec.nis_rad then
          ll_commit := ll_commit + 1;
        end if;
      
        if mod(ll_commit, 1000) = 0 then
          commit;
        end if;
      
        ll_nis_rad := lcur_readings_rec.nis_rad;
      
      exception
        when dup_val_on_index then
          null;
        when others then
          dbms_output.put_line(sqlerrm || ':' || lcur_readings_rec.nis_rad);
      end;
    
    end loop;
  
    update apmedida_co co
       set tip_lect = 'RA003'
     where programa = 'CONV_EDM'
       and (nis_rad, f_fact, tip_csmo) in
           (select nis_rad, min(f_fact), tip_csmo
              from apmedida_co
             where nis_rad = co.nis_rad
               and tip_csmo = co.tip_csmo
             group by nis_rad, tip_csmo);
  
    commit;
  
    begin
    
      update apmedida_co set num_rue = 4 where num_rue < 4;
    
      for x in (select *
                  from (select nis_rad, num_apa, co_marca,
                                max(length(lect)) len, num_rue
                           from apmedida_co
                          group by nis_rad, num_apa, co_marca, num_rue)
                 where len > num_rue) loop
      
        update apmedida_co
           set num_rue = x.len
         where nis_rad = x.nis_rad
           and num_apa = x.num_apa
           and co_marca = x.co_marca;
      
      end loop;
    end;
  
    commit;
  end p06_readings;

  procedure p07_reading_routes is
    /*
    * This is not the proper way to create reading routes and itineraries.
    * This is only done for the purposes of testing if the conversion has
    * all the required data.
    *
    */
    cursor lcur_route is
      select tournee, a.centre, cod_unicom
        from edmgalatee.ag a, int_centre_unicom u
       where tournee <> '000'
         and a.centre = u.centre
         and (a.centre, a.ag) in
             (select centre, client
                from int_supply
               where nis_rad is not null)
         and cod_unicom <> 1026
       group by tournee, a.centre, cod_unicom;
  
    cursor lcur_order(cls_tournee in varchar2, cls_centre in varchar2) is
      select s.nis_rad, s.nif, s.sec_nis, a.centre, a.client, s.cod_mask,
             s.f_alta, s.cod_unicom, to_number(o.ordretournee)
        from sumcon s, int_supply a, edmgalatee.ag o
       where s.nis_rad = a.nis_rad
         and o.centre = cls_centre
         and o.tournee = cls_tournee
         and o.centre = a.centre
         and o.ag = a.client
       order by to_number(o.ordretournee);
    lf_ciclo      date;
    ll_day        number;
    ll_ruta       number;
    ll_mitin      number;
    ll_aol_fin    number;
    ll_cod_unicom number;
  begin
    for lcur_route_rec in lcur_route loop
    
      ll_cod_unicom := lcur_route_rec.cod_unicom;
    
      select nvl(max(ruta), 0) + 1
        into ll_ruta
        from rutas
       where cod_unicom = ll_cod_unicom;
    
      select nvl(max(num_itin), 0) + 1 into ll_mitin from mitin;
      --where cod_unicom = ll_cod_unicom;
    
      begin
        insert into rutas
          (usuario, f_actual, programa, cod_unicom, ruta, tip_ruta,
           desc_ruta, t_ruta, ult_nif_selecc, ind_asig_contrata, cod_ctrat,
           cod_mask, tip_distrib, ind_genweekends, ind_genholidays,
           ind_geninoneday, f_expire)
        values
          (gls_usuario, trunc(sysdate), gls_programa, ll_cod_unicom,
           ll_ruta, 'RU012', 'BOOK - ' || lcur_route_rec.tournee, 0, 0, 2, 0,
           1024, 'LD001', 0, 0, 0, glf_fechanulla);
      
      exception
        when others then
          dbms_output.put_line(lcur_route_rec.tournee || ' ' ||
                               lcur_route_rec.centre || ' RUTA = ' ||
                               ll_ruta);
      end;
    
      insert into mitin
        (usuario, f_actual, programa, cod_unicom, ruta, num_itin, desc_itin,
         t_itin, nif_prim, nif_ult, ind_ubic_reubic, tip_distrib, f_expire,
         avg_read_time, transport_type, default_reader, cod_cnae, ind_proc)
      values
        (gls_usuario, trunc(sysdate), gls_programa, ll_cod_unicom, ll_ruta,
         ll_mitin, 'BOOK - ' || lcur_route_rec.tournee, 0, 0, 0, 1, 'LD001',
         glf_fechanulla, 0, 'AM000', 0, 0, 0);
    
      --Put dummy cycles..................
      select rw
        into ll_day
        from (select rw
                 from ((select rownum rw
                           from (select 1 from dual group by cube(1, 2, 3, 4, 5))
                          where rownum <= 28) order by dbms_random.random))
       where rownum <= 1;
      for i in 1 .. 12 loop
      
        lf_ciclo := to_date('2013' || lpad(i, 2, 0) || lpad(ll_day, 2, 0),
                            'yyyymmdd');
      
        insert into ciclos_ruta
          (usuario, f_actual, programa, cod_unicom, ruta, ciclo, anyo,
           est_ci_ruta, nl_aus, nl_an, nl_ok, nl_gen, f_iteor, f_fteor,
           f_ireal, f_freal, ind_lect_real, t_generado, t_restante, nl_estim,
           nl_norealiz, na_gen, na_ok, na_aus, na_an, na_no_realiz, na_estim,
           nc_gen, nc_ok, nc_aus, nc_an, nc_no_realiz, nc_estim)
        values
          (gls_usuario, trunc(sysdate), gls_programa, ll_cod_unicom,
           ll_ruta, i, 2013, 'EU001', 0, 0, 0, 0, lf_ciclo, lf_ciclo,
           glf_fechanulla, glf_fechanulla, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0);
      
        insert into ciclos_itin
          (usuario, f_actual, programa, cod_unicom, ruta, num_itin, ciclo,
           est_itin, nl_aus, nl_an, nl_ok, nl_gen, f_lteor, f_gen, f_recep,
           f_lreal, f_trat, f_fact, cod_lector, accion, num_tpl, nl_estim,
           nl_norealiz, f_estim, ind_trat, read_time, na_gen, na_ok, na_aus,
           na_an, na_no_realiz, na_estim, nc_gen, nc_ok, nc_aus, nc_an,
           nc_no_realiz, nc_estim)
        values
          (gls_usuario, trunc(sysdate), gls_programa, ll_cod_unicom,
           ll_ruta, ll_mitin, i, 'IR005', 0, 0, 0, 0, lf_ciclo,
           glf_fechanulla, glf_fechanulla, glf_fechanulla, glf_fechanulla,
           glf_fechanulla, 0, 0, 0, 0, 0, glf_fechanulla, 0, -1, 0, 0, 0, 0,
           0, 0, 0, 0, 0, 0, 0, 0);
      
      end loop;
    
      ll_aol_fin := 0;
    
      for lcur_order_rec in lcur_order(lcur_route_rec.tournee,
                                       lcur_route_rec.centre) loop
      
        ll_aol_fin := ll_aol_fin + 1;
      
        insert into fincas_per_lect
          (usuario, f_actual, programa, nif, cod_unicom, ruta, num_itin,
           aol_fin, tip_per_lect, f_ureubi, cod_mask)
        values
          (gls_usuario, trunc(sysdate), gls_programa, lcur_order_rec.nif,
           lcur_order_rec.cod_unicom, ll_ruta, ll_mitin, ll_aol_fin, 'RU012',
           lcur_order_rec.f_alta, lcur_order_rec.cod_mask);
      
      end loop;
    
    end loop;
  end p07_reading_routes;

  procedure unpaid_bill_concepts(pll_nis_rad in number, plf_fact in date,
                                 pll_imp_tot_rec in number);

  procedure p20_billing(pll_nis_rad in number default 0) is
    /*
    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    &&
    &&
    &&
    &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    */
    cursor lcur_accounts is
      select *
        from int_supply s
       where nis_rad is not null
         and (nis_rad = pll_nis_rad or 0 = pll_nis_rad)
         and not exists
       (select 0 from recibos where nis_rad = s.nis_rad);
  
    lf_fact        date;
    ll_imp_tot_rec number;
    ls_est_act     varchar2(5);
  begin
    for lcur_accounts_rec in lcur_accounts loop
    
      if lcur_accounts_rec.centre = '999' then
        ll_imp_tot_rec := 0;
        lf_fact        := trunc(sysdate);
      else
      
        select nvl(sum(decode(dc, 'D', montant, -montant)), 0)
          into ll_imp_tot_rec
          from edmgalatee.lclient l, int_supply s
         where l.centre = s.centre
           and l.client = s.client
           and l.ordre = s.ordre
           and s.nis_rad = lcur_accounts_rec.nis_rad;
      
        select nvl(max(f_fact), trunc(sysdate))
          into lf_fact
          from apmedida_co
         where nis_rad = lcur_accounts_rec.nis_rad;
      
      end if;
    
      /*select nvl(max(dfac), trunc(sysdate))
       into lf_fact
       from edmgalatee.entfac
      where centre = lcur_accounts_rec.centre
        and client = lcur_accounts_rec.client
        and ordre = lcur_accounts_rec.ordre;*/
    
      if ll_imp_tot_rec > 0 then
        ls_est_act := 'ER020';
      elsif ll_imp_tot_rec < 0 then
        ll_imp_tot_rec := 0;
        ls_est_act     := 'ER310';
      else
        ls_est_act := 'ER310';
      end if;
    
      insert into recibos
        (usuario, f_actual, programa, sec_rec, nis_rad, sec_nis, f_fact,
         imp_tot_rec, est_act, f_est_act, cod_cli, sec_cta, op_cambest,
         f_p_camb_est, num_meses_fact, num_fact, num_fact_anul, sec_mod,
         sec_rec_anul, f_fact_anul, num_plza_abon, imp_cta, tip_cli, tip_cta,
         num_acu, cod_unicom, f_prev_corte, f_vcto_fac, ind_recar, ind_multa,
         num_dias_rec, aj_redon, cod_tar, gr_concepto, f_fact_ant,
         nro_factura, f_cobro, ind_cuota, ind_conversion, f_vcto_prox_fac,
         ind_ajuste, tip_fact, f_proc_cobro, ind_impuesto, cod_agencia,
         cod_sucursal, tip_cencobro, sec_remesa, tip_rec, co_cond_fiscal,
         ind_real_est, f_puesta_cobro, ind_gestion_cuenta, simbolo_var,
         num_ident_sipo, num_fiscal, periodo_contable, prioridad, ind_ref,
         f_fact_regul, sec_rec_regul, correo_entrega, distrito_entrega,
         num_id_sipo, sie_simbolo_var, sec_est_act, cod_ref, cod_mask,
         imp_charges, imp_amort, f_last_recargo, f_last_multa, ind_incl_gs,
         shift_camb_est, cod_cli_trn, sec_cta_trn, num_cnto, cod_ministry,
         ind_included, nir_included)
      values
        (gls_usuario, trunc(sysdate), gls_programa, 1,
         lcur_accounts_rec.nis_rad, lcur_accounts_rec.sec_nis, lf_fact,
         ll_imp_tot_rec, ls_est_act, trunc(sysdate),
         lcur_accounts_rec.cod_cli, lcur_accounts_rec.sec_cta, ' ',
         glf_fechanulla, 0, ' ', 0, 0, 0, glf_fechanulla, 0, 0 /*imp_cta*/,
         lcur_accounts_rec.tip_cli, 'CU001', 0, lcur_accounts_rec.cod_unicom,
         decode(ll_imp_tot_rec, 0, glf_fechanulla, trunc(sysdate)),
         lf_fact + 14, 2, 2, 0, 0, lcur_accounts_rec.cod_tar,
         lcur_accounts_rec.gr_concepto, glf_fechanulla, 0,
         decode(ll_imp_tot_rec, 0, glf_fechanulla, trunc(sysdate)), 2, 1,
         glf_fechanulla, 0, 'FT011',
         decode(ll_imp_tot_rec, 0, glf_fechanulla, trunc(sysdate)), 2, 1,
         lcur_accounts_rec.cod_unicom, 'CC001', 0, 'TR110', 'FC540', 1,
         trunc(sysdate), 2, ' ', ' ', ' ', glf_fechanulla, 9999, 2,
         glf_fechanulla, 0, 0, 0, 0, glf_fechanulla, 1, 0,
         lcur_accounts_rec.cod_mask, ll_imp_tot_rec, 0, glf_fechanulla,
         glf_fechanulla, 0, 0, 0, 0, 0, 'IT000', 2, ' ');
    
      insert into hfacturacion
        (usuario, f_actual, programa, sec_rec, nis_rad, sec_nis, f_fact,
         csmo_fact, pot_fact, imp_fact, f_fact_sust, ind_rest, ind_val_fact,
         tip_fact, imp_cv, num_cv_fact, mod_estm, sec_rec_sust, csmo_react,
         pot_leida, cont_trans_pot_ant, f_prox_vto, csmo_fact_punta,
         csmo_fact_valle, csmo_fact_llano, pot_fact_punta, pot_fact_valle,
         pot_fact_llano, pot_leida_punta, pot_leida_valle, pot_leida_llano,
         ind_f_lect_control, ind_f_lvnto, imp_anticipos, num_anticipos_fact,
         f_lect, f_lect_ant, imp_iva_antic, tip_cta, tip_rec, imp_charges,
         period, period_tip_per_fact)
      values
        (gls_usuario, trunc(sysdate), gls_programa, 1,
         lcur_accounts_rec.nis_rad, lcur_accounts_rec.sec_nis, lf_fact, 0, 0,
         ll_imp_tot_rec, glf_fechanulla, 1, 1, 'FT011', 0, 0, 0, 0, 0, 0, 0,
         glf_fechanulla, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, lf_fact,
         glf_fechanulla, 0, 'CU001', 'TR110', ll_imp_tot_rec,
         to_char(sysdate, 'yyyymm'), 'PF012');
    
      insert into est_rec
        (usuario, f_actual, programa, sec_rec, nis_rad, sec_nis, f_fact,
         sec_est_rec, est_rec, f_inc_est, desc_est_rec)
      values
        (gls_usuario, trunc(sysdate), gls_programa, 1,
         lcur_accounts_rec.nis_rad, lcur_accounts_rec.sec_nis, lf_fact, 1,
         ls_est_act, trunc(sysdate), ' ');
    
      if ll_imp_tot_rec > 0 then
        unpaid_bill_concepts(lcur_accounts_rec.nis_rad, lf_fact,
                             ll_imp_tot_rec);
      else
        insert into imp_concepto
          (usuario, f_actual, programa, sec_rec, nis_rad, sec_nis, f_fact,
           co_concepto, sec_concepto, csmo_fact, prec_concepto, imp_concepto,
           porc_concepto, base_calc_imp, ind_diff, imp_iva, ind_pago,
           desc_pago, imp_cta_cto, nir_srv, nir_asoc, imp_used, ind_arrear)
        values
          (gls_usuario, trunc(sysdate), gls_programa, 1,
           lcur_accounts_rec.nis_rad, lcur_accounts_rec.sec_nis, lf_fact,
           'CC261', 1, 0, 0, 0, 0, 0, 0, 0, 1, ' ', 0, ' ', ' ', 0, 0);
      end if;
    
    end loop;
  
    /*  Updates for COD_REF */
    begin
      --update sumcon set sec_factura = 1 where sec_factura = 0;
    
      begin
        for x in (select s.nis_rad || lpad(s.sec_factura, 3, '0') as cod_ref,
                         nis_rad
                    from sumcon s) loop
          update recibos
             set cod_ref = x.cod_ref, simbolo_var = x.cod_ref
           where nis_rad = x.nis_rad;
        end loop;
      end;
    
      update recibos
         set cod_ref = to_char(cod_ref) ||
                        substr(to_char(11 -
                                       mod(((to_number(substr(to_char(cod_ref),
                                                              1, 1)) * 2) +
                                           (to_number(substr(to_char(cod_ref),
                                                              2, 1)) * 3) +
                                           (to_number(substr(to_char(cod_ref),
                                                              3, 1)) * 4) +
                                           (to_number(substr(to_char(cod_ref),
                                                              4, 1)) * 5) +
                                           (to_number(substr(to_char(cod_ref),
                                                              5, 1)) * 6) +
                                           (to_number(substr(to_char(cod_ref),
                                                              6, 1)) * 7) +
                                           (to_number(substr(to_char(cod_ref),
                                                              7, 1)) * 2) +
                                           (to_number(substr(to_char(cod_ref),
                                                              8, 1)) * 3) +
                                           (to_number(substr(to_char(cod_ref),
                                                              9, 1)) * 4) +
                                           (to_number(substr(to_char(cod_ref),
                                                              10, 1)) * 5) +
                                           (to_number(substr(to_char(cod_ref),
                                                              11, 1)) * 6) +
                                           (to_number(substr(to_char(cod_ref),
                                                              12, 1)) * 7)), 11)),
                               -1)
       where ind_conversion = 1;
    end;
    commit;
  end p20_billing;

  procedure unpaid_bill_concepts(pll_nis_rad in number, plf_fact in date,
                                 pll_imp_tot_rec in number) is
    cursor lcur_main is
      select * from int_supply where nis_rad = pll_nis_rad;
  
    cursor lcur_concepts is
      select aa.*,
             billed - (fixed_charge + radio + garbage + energy + tax) extra
        from (select sum(decode(dc, 'D', montant, -montant)) as amount,
                      sum(decode(dc, 'D', montant)) as billed,
                      nvl(sum(decode(dc, 'C', montant)), 0) as paid,
                      max((select nvl(sum(totredht), 0)
                             from edmgalatee.redfac
                            where facture = l.ndoc
                              and client = l.client
                              and redevance in ('11', '12'))) as fixed_charge,
                      max((select nvl(sum(totredht), 0)
                             from edmgalatee.redfac
                            where facture = l.ndoc
                              and client = l.client
                              and redevance in ('14'))) as radio,
                      max((select nvl(sum(totredht), 0)
                             from edmgalatee.redfac
                            where facture = l.ndoc
                              and client = l.client
                              and redevance in ('15'))) as garbage,
                      max((select nvl(sum(totredht), 0)
                             from edmgalatee.redfac
                            where facture = l.ndoc
                              and client = l.client
                              and redevance in ('01', '02', '03'))) as energy,
                      nvl(max(e.totftax), 0) tax
                 from edmgalatee.lclient l, int_supply s, edmgalatee.entfac e
                where l.centre = s.centre
                  and l.client = s.client
                  and l.ordre = s.ordre
                  and s.nis_rad is not null
                  and e.facture = ndoc
                  and e.client = l.client
                  and s.nis_rad = pll_nis_rad) aa;
    ll_paid             number := 0;
    ll_payconc          number := 0;
    ll_sec_concepto     number := 0;
    ll_imp_concepto     number := 0;
    ll_tot_imp_concepto number := 0;
    ls_co_concepto      varchar2(5) := ' ';
  begin
    for lcur_main_rec in lcur_main loop
      for lcur_concepts_rec in lcur_concepts loop
      
        ll_payconc := lcur_concepts_rec.paid;
      
        for i in 1 .. 5 loop
          ll_sec_concepto := ll_sec_concepto + 1;
        
          if i = 1 then
            ls_co_concepto  := 'CC503';
            ll_imp_concepto := lcur_concepts_rec.tax;
          elsif i = 2 then
            ls_co_concepto  := 'CC120';
            ll_imp_concepto := lcur_concepts_rec.radio;
          elsif i = 3 then
            ls_co_concepto  := 'CC100';
            ll_imp_concepto := lcur_concepts_rec.fixed_charge;
          elsif i = 4 then
            ls_co_concepto  := 'CC130';
            ll_imp_concepto := lcur_concepts_rec.garbage;
          elsif i = 5 then
            ls_co_concepto  := 'CC261';
            ll_imp_concepto := lcur_concepts_rec.energy +
                               lcur_concepts_rec.extra;
          
          end if;
        
          ll_tot_imp_concepto := ll_tot_imp_concepto + ll_imp_concepto;
        
          if ll_payconc > 0 then
            if ll_payconc > ll_imp_concepto then
              ll_paid    := ll_imp_concepto;
              ll_payconc := ll_payconc - ll_imp_concepto;
            else
              ll_paid    := ll_payconc;
              ll_payconc := 0;
            end if;
          else
            ll_paid := 0;
          end if;
        
          ll_imp_concepto := nvl(ll_imp_concepto, 0);
        
          insert into imp_concepto
            (usuario, f_actual, programa, sec_rec, nis_rad, sec_nis, f_fact,
             co_concepto, sec_concepto, csmo_fact, prec_concepto,
             imp_concepto, porc_concepto, base_calc_imp, ind_diff, imp_iva,
             ind_pago, desc_pago, imp_cta_cto, nir_srv, nir_asoc, imp_used,
             ind_arrear)
          values
            (gls_usuario, trunc(sysdate), gls_programa, 1,
             lcur_main_rec.nis_rad, lcur_main_rec.sec_nis, plf_fact,
             ls_co_concepto, ll_sec_concepto, 0, 0, ll_imp_concepto, 0,
             ll_imp_concepto, 0, 0, 1, ' ', ll_paid, ' ', ' ', 0, 0);
        end loop;
      
        --Test if the amounts are matching
        select sum(imp_concepto) - sum(e.imp_cta_cto)
          into ll_imp_concepto
          from imp_concepto e
         where nis_rad = pll_nis_rad;
      
      end loop;
      if ll_imp_concepto <> pll_imp_tot_rec then
        dbms_output.put_line('... Mismatch on amounts >>' ||
                             lcur_main_rec.nis_rad);
      end if;
    end loop;
  end unpaid_bill_concepts;

  procedure p30_deposits is
    cursor lcur_deposits is
      select s.*, i.deposit_date, i.deposit
        from int_deposits i, int_supply s
       where s.nis_rad is not null
         and s.centre = i.centre
         and s.client = i.client
         and s.ordre = i.ordre
         and not exists
       (select 0 from cargvar where nis_rad = s.nis_rad);
  begin
    for lcur_deposits_rec in lcur_deposits loop
      insert into cargvar
        (usuario, f_actual, programa, sec_rec, nis_rad, sec_nis, f_fact,
         co_cargo, sec_cargo, est_act, f_est_act, num_fact, doc_soporte,
         f_prod_inic, cod_unicom, cod_agencia, cod_sucursal, tip_cli,
         cod_tar, imp_cargo, imp_fact_cargo, imp_fact_total, aj_redon,
         cod_cli, sec_cta, f_cobro, f_extracto, numero_extracto,
         sec_movimiento, periodo_contable, clave_coberror, nis_rad_regul,
         sec_nis_regul, tip_cta, sie_simbolo_var, nir_refer, num_cheque,
         cod_agencia_cheque, cod_sucursal_cheque, porc_rebaja, texto, datos,
         sie_forma_pago, cod_ministry)
      values
        (gls_usuario, trunc(sysdate), gls_programa, 0,
         lcur_deposits_rec.nis_rad, lcur_deposits_rec.sec_nis,
         lcur_deposits_rec.deposit_date, 'VA160', 1, 'EV900',
         lcur_deposits_rec.deposit_date, ' ', ' ',
         lcur_deposits_rec.deposit_date, lcur_deposits_rec.cod_unicom, 0, 0,
         lcur_deposits_rec.tip_cli, lcur_deposits_rec.cod_tar,
         lcur_deposits_rec.deposit, lcur_deposits_rec.deposit,
         lcur_deposits_rec.deposit, 0, lcur_deposits_rec.cod_cli, 1,
         lcur_deposits_rec.deposit_date, glf_fechanulla, 0, 0,
         glf_fechanulla, 0, 0, 0, 'CU001', glf_fechanulla, ' ', ' ', 0, 0, 0,
         ' ', ' ', 'XM999', 'IT000');
    end loop;
  end p30_deposits;

end conversion_pck;
/
